#!/usr/bin/env python3
# -*- mode: python; -*-
import json
import argparse
import logging
import sys
import re
import configparser
from collections import defaultdict
import os.path
from urllib import request
import base64
import copy
import time
import subprocess
import traceback
import platform
import socket
import tempfile
import zipfile

__VERSION__ = '0.3'

default_logging_level = logging.INFO
LATEST_V2RAY_TAG_URL = 'https://api.github.com/repos/v2ray/v2ray-core/releases/latest'
V2RAY_DOWNLOAD_LINK = "https://github.com/v2ray/v2ray-core/releases/download/v{version}/v2ray-{arch}.zip"
CONFIG = 'config.ini'


class GFWException(Exception):
    pass


class Logger():
    def __init__(self, name):
        logformat = '%(asctime)s %(name)s: %(levelname)s [%(funcName)s/%(lineno)d] %(message)s'
        self.logger = logging.getLogger(name)
        self.logger.setLevel(default_logging_level)
        if not self.logger.handlers:
            myhandler = logging.StreamHandler(stream=sys.stdout)
            myhandler.setFormatter(logging.Formatter(logformat))
            self.logger.addHandler(myhandler)


class Utils(object):
    logger = Logger('Utils').logger

    @staticmethod
    def get_command_version(args, regex):
        p = subprocess.run(args, capture_output=True)
        if p.returncode:
            raise GFWException('Command {} run faild: {}'.format(args, p.stderr))
        if p.stdout:
            match_str = p.stdout.decode('utf-8')
            m = re.search(regex, match_str)
            if m:
                return [int(v) for v in m.groups()]
        raise GFWException('No version found for command {}'.format(args))

    @staticmethod
    def str_to_list(ips):
        if ips:
            res = re.split(r' *[,;] *', ips)
        else:
            res = []
        return res

    @staticmethod
    def split_ip_port(ip, default_port):
        ip_pair = ip.split(':')
        if len(ip_pair) > 1:
            ip = ip_pair[0]
            port = ip_pair[1]
        else:
            ip = ip_pair[0]
            port = default_port
        return ip, int(port)

    @staticmethod
    def read_file_to_list(filename):
        lines = []
        with open(filename, 'r') as infile:
            lines = infile.read().splitlines()
        return lines

    @staticmethod
    def run_command(args, stdout=None, stderr=None, background=False):
        Utils.logger.debug('Run command {}'.format(args))
        p = subprocess.Popen(args, stdout=stdout, stderr=stderr, stdin=None)
        if not background:
            p.wait()
            return p.returncode
        else:
            return p

    @staticmethod
    def get_pid(pid_file):
        lines = None
        if os.path.exists(pid_file):
            with open(pid_file, 'r') as fh:
                lines = fh.read().splitlines()

        if lines:
            return int(lines[0].rstrip())
        else:
            return None

    @staticmethod
    def is_port_open(ports):
        if type(ports) is not list:
            ports = [ports]

        for port in ports:
            with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as sock:  # TCP
                try:
                    result = sock.connect_ex(('127.0.0.1', int(port)))
                    if result != 0:
                        raise GFWException("Port {} is closed".format(port))
                    else:
                        Utils.logger.debug("Port {} is open".format(port))
                except Exception as e:
                    Utils.logger.debug(e)
                    return False
        return True

    @staticmethod
    def is_pid_alive(pid):
        if not pid:
            return False

        try:
            os.kill(pid, 0)
        except Exception:
            return False
        return True

    @staticmethod
    def is_pid_alive_from_file(pid_file):
        pid = Utils.get_pid(pid_file)
        if pid:
            return Utils.is_pid_alive(pid)
        else:
            return False

    @staticmethod
    def stop_from_pid_file(pid_file):
        pid = Utils.get_pid(pid_file)
        if Utils.is_pid_alive(pid):
            os.kill(pid, 9)
        return True

    @staticmethod
    def find_file(fname):
        my_path = os.path.dirname(os.path.abspath(__file__))
        fname_with_path = '{}/{}'.format(my_path, fname)
        if os.path.exists(fname):
            return fname
        elif os.path.exists(fname_with_path):
            return fname_with_path
        raise GFWException('File {} not found.'.format(fname))

    @staticmethod
    def which(program, path_list=None):
        if not path_list:
            path_list = []

        def is_exe(fpath):
            return os.path.isfile(fpath) and os.access(fpath, os.X_OK)

        fpath, fname = os.path.split(program)
        if fpath:
            if is_exe(program):
                return program
        else:
            for path in [*path_list, *os.environ["PATH"].split(os.pathsep)]:
                exe_file = os.path.join(path, program)
                if is_exe(exe_file):
                    return exe_file

        return None


class Prog(object):
    def __init__(self, command, args, pid_file, bin_path=None):
        self.logger = Logger(self.__class__.__name__).logger

        self.pid_file = pid_file
        self.args = args or []

        self.name = command
        self.command = Utils.which(command, bin_path)
        if not self.command:
            raise GFWException('Command {} not found.'.format(command))

    def start(self, ignore_pid_file=False):
        self._ensure_prog_is_not_running()
        process = Utils.run_command([self.command, *self.args], background=True)
        max_time = 2  # 如果 2s 之后程序还在运行，就认为程序执行启动成功
        try:
            process.wait(max_time)
            code = process.poll()
            if code:
                raise GFWException('command faild with code: {}'.format(code))
        except subprocess.TimeoutExpired:
            pass

        self.logger.debug('done, pid {}'.format(process.pid))
        if not ignore_pid_file:
            with open(self.pid_file, 'w') as fh:
                fh.write(str(process.pid))

    def _ensure_prog_is_not_running(self):
        if Utils.is_pid_alive_from_file(self.pid_file):
            raise GFWException("Previouse process is still running")
        else:
            self.logger.debug('prog not running')

    def stop(self):
        if Utils.stop_from_pid_file(self.pid_file):
            self.logger.debug('done')
        else:
            self.logger.debug('stop faild')

    def status(self):
        if Utils.is_pid_alive_from_file(self.pid_file):
            self.logger.info('{} is running'.format(self.name))
        else:
            self.logger.info('{} is dead'.format(self.name))


class Iptable(object):
    def __init__(self, run_dir, rules, dnsmasq_port, domestic_dns, ip_blacklists_src, ip_blacklists_dst):
        self.logger = Logger(self.__class__.__name__).logger

        command = 'iptables'
        self.command = Utils.which(command)
        if not self.command:
            raise GFWException('Command {} not found.'.format(command))

        self.chain_name = 'SVGFW'
        self.start_commands = [
            [self.command, '-t', 'nat', '-N', self.chain_name],
            [self.command, '-t', 'nat', '-N', self.chain_name],
        ]

        for ip in ip_blacklists_src:
            self.start_commands.append([
                self.command, '-t', 'nat', '-A', self.chain_name, '-s', ip, '-j', 'ACCEPT'
            ])

        for ip in ip_blacklists_dst:
            self.start_commands.append([
                self.command, '-t', 'nat', '-A', self.chain_name, '-d', ip, '-j', 'ACCEPT'
            ])

        self.start_commands.extend([
            # accept the domestic dns request
            [self.command, '-t', 'nat', '-A', self.chain_name, '-d', domestic_dns,
             '-p', 'udp', '--dport', '53', '-j', 'ACCEPT'],

            # hijack all other dns requests
            [self.command, '-t', 'nat', '-A', self.chain_name, '-p', 'udp', '--dport', '53',
             '-j', 'REDIRECT', '--to-ports', dnsmasq_port],

            [self.command, '-t', 'nat', '-A', 'PREROUTING', '-j', self.chain_name],  # lan
            [self.command, '-t', 'nat', '-A', 'OUTPUT', '-j', self.chain_name],  # router
        ])

        self.stop_commands = [
            [self.command, '-t', 'nat', '-D', 'PREROUTING', '-j', self.chain_name],
            [self.command, '-t', 'nat', '-D', 'OUTPUT', '-j', self.chain_name],
            [self.command, '-t', 'nat', '-F', self.chain_name],  # flush chain
            [self.command, '-t', 'nat', '-X', self.chain_name],  # delete chain
        ]

        for rule in rules:
            self.start_commands.append([
                'ipset', 'create', rule.name, 'hash:net'
            ])
            self.stop_commands.append(
                ['ipset', 'destroy', rule.name]
            )

            self.start_commands.append([
                self.command, '-t', 'nat', '-A', self.chain_name,
                '-p', 'tcp',
                '-m', 'set', '--match-set', rule.name, 'dst',
                '-j', 'REDIRECT', '--to-ports', rule.socks_local_port
            ])
            self.start_commands.append([
                self.command, '-t', 'nat', '-A', self.chain_name,
                '-p', 'udp',
                '-m', 'set', '--match-set', rule.name, 'dst',
                '-j', 'REDIRECT', '--to-ports', rule.socks_local_port
            ])

    def start(self):
        self.logger.debug('start iptables')
        for args in self.start_commands:
            Utils.run_command(args)

    def stop(self):
        self.logger.debug('stop iptables')
        for args in self.stop_commands:
            Utils.run_command(args)

    def _is_alive(self):
        args = [self.command, '-t', 'nat', '-nL', self.chain_name]
        chain_name_pos = 4  # 这个位置是规则名称
        should_count_rule_command_length = 5  # 长度大于 5 的是具体规则
        total_rule_count = 0
        for command in self.start_commands:
            if ((re.search('iptables', command[0]))
                    and (command[chain_name_pos] == self.chain_name)
                    and (len(command) > should_count_rule_command_length)):
                total_rule_count += 1

        with tempfile.NamedTemporaryFile(delete=True) as fh:
            code = Utils.run_command(args, stdout=fh)
            if code:
                self.logger.warning("iptables command run faild, assume the command itself is ok")
                return False
            fh.seek(0)
            rule_count = len(fh.readlines())

            if total_rule_count + 2 == rule_count:
                return True
        return False

    def status(self):
        if self._is_alive():
            self.logger.info('iptable is running')
        else:
            self.logger.info('iptables is dead')

    def keep_alive(self):
        if not self._is_alive():
            self.logger.info('dead, do restart')
            self.stop()
            self.start()
        else:
            self.logger.info('alive')


class V2ray(object):
    def __init__(self, run_dir, conf, rules, international_dns, international_dns_local_port):
        self.logger = Logger(self.__class__.__name__).logger
        dns = international_dns
        dns_local_port = international_dns_local_port

        self.config_file = "{}/v2ray_config.json".format(run_dir)
        self.pid_file = "{}/v2ray.pid".format(run_dir)
        self.log_file = "{}/v2ray.log".format(run_dir)

        try:
            local_bin_path = [Utils.find_file('./bin')]
        except Exception:
            local_bin_path = []

        self.prog = Prog('v2ray', args=['--config', self.config_file],
                         bin_path=[*local_bin_path, '/opt/v2ray', '/usr/local/bin', '/usr/bin/v2ray'],
                         pid_file=self.pid_file)

        self.version = Utils.get_command_version(['v2ray', '--version'],
                                                 r'V2Ray (\d)\.(\d+)\.(\d+)')

        self.logger.debug('V2ray version {}'.format(self.version))

        outbounds = conf['outbounds']
        inbounds = conf['inbounds']
        self.rules = rules

        outbounds = re.sub(r'//.*', '', outbounds, re.M)  # remove comments
        self.outbounds = json.loads(outbounds)

        self._check_v2ray_config()

        inbounds = re.sub(r'//.*', '', inbounds, re.M)  # remove comments
        if inbounds:
            inbounds = json.loads(inbounds)

        self.config = {
            'log': {"loglevel": "none"},
            'inbounds': self._get_v2ray_inbounds(dns_local_port, dns, inbounds or []),
            'outbounds': self.outbounds,
            'routing': self._get_v2ray_routing(inbounds)
        }

    def __repr__(self):
        return {
            'inbounds': self.config['inbounds'],
            'routing': self.config['routing']
        }.__repr__()

    def _check_v2ray_config(self):
        tags = {}
        for outbound in self.outbounds:
            if outbound.get('tag'):
                tags[outbound['tag']] = 1
            else:
                raise GFWException('Outbound must set a tag: '.format(outbound))

        for rule in self.rules:
            if not tags.get(rule.name):
                raise GFWException('Outbound tag for "{}" not found'.format(rule.name))

    def start(self):
        self.logger.debug('start v2ray')
        with open(self.config_file, 'w') as fh:
            fh.write(json.dumps(self.config, indent=4))

        self.prog.start()

    def stop(self):
        self.logger.debug('stop v2ray')
        self.prog.stop()

    def status(self):
        self.prog.status()

    def _get_v2ray_inbounds(self, dns_local_port, dns, ext_inbounds):
        dns, port = Utils.split_ip_port(dns, 53)
        inbounds = []
        dns_inbound = {
            "tag": "dns",
            "protocol": "dokodemo-door",
            "port": int(dns_local_port),
            "settings": {
                "address": dns,
                "port": int(port),
                "network": "udp,tcp",
                "followredirect": False
            }
        }
        inbounds.append(dns_inbound)

        socks_inbound_template = {
            "protocol": "dokodemo-door",
            "listen": "0.0.0.0",
            "settings": {
                "followRedirect": True,
                "network": "tcp,udp",
                "timeout": 10
            }
        }

        for rule in self.rules:
            inbound = copy.deepcopy(socks_inbound_template)
            inbound['tag'] = '{}_1'.format(rule.name)  # v2ray didn't support gfwlist as tag name
            inbound['port'] = int(rule.socks_local_port)
            inbounds.append(inbound)

        for inb in ext_inbounds:
            inbounds.append(inb)

        return inbounds

    def keep_alive(self):
        ports = []
        for out in self.config['inbounds']:
            ports.append(out['port'])

        if not Utils.is_port_open(ports):
            self.logger.info('dead, do restart')
            self.stop()
            self.start()
        else:
            self.logger.info('alive')

    def _get_v2ray_routing(self, ext_inbounds):
        routings = []

        routing_template = {
            "type": "field",
            "network": "tcp,udp"
        }

        for rule in self.rules:
            routing = copy.deepcopy(routing_template)
            routing['inboundTag'] = ['{}_1'.format(rule.name)]
            routing['outboundTag'] = rule.name
            routings.append(routing)

        routings[-1]['inboundTag'].append('dns')  # dns proxy use gfwlist rule
        for inbound in ext_inbounds:
            routings[-1]['inboundTag'].append(inbound['tag'])

        return {'rules': routings}

    def _install_binary(self, version, dstpath):
        files_to_update = ['v2ctl', 'v2ray', 'v2ctl.sig', 'v2ray.sig', 'geoip.dat', 'geosite.dat']

        for f in files_to_update:
            fpath = '{}/{}'.format(dstpath, f)
            if not ((not os.path.exists(fpath) and os.access(dstpath, os.W_OK))
                    or os.access(fpath, os.W_OK)):
                raise GFWException("file {} can't be write".format(fpath))

        uname = platform.uname()
        arch = ''
        if uname.system == 'Darwin':
            arch = 'macos'
        elif uname.system == 'Linux':
            if uname.machine == 'aarch64':
                arch = 'linux-arm64'
        if not arch:
            self.logger.info('this system not support update: {}'.format(uname))
            return

        link = V2RAY_DOWNLOAD_LINK.format(version='.'.join([str(v) for v in version]), arch=arch)
        resp = request.urlopen(link)
        if resp.status != 200:
            raise GFWException('download zip file faild.')

        tmpfile = tempfile.NamedTemporaryFile(delete=True)
        self.logger.debug('tempfile is {}'.format(tmpfile.name))
        tmpfile.write(resp.read())
        with zipfile.ZipFile(tmpfile) as zip:
            with tempfile.TemporaryDirectory() as tmppath:
                self.logger.debug('extract files {} to {}'.format(files_to_update, tmppath))
                zip.extractall(members=files_to_update, path=tmppath)
                for fname in files_to_update:
                    fsrc = '{}/{}'.format(tmppath, fname)
                    fdst = '{}/{}'.format(dstpath, fname)
                    self.logger.debug('cp {}'.format(fdst))
                    os.system('cp -p {} {}'.format(fsrc, fdst))
                    if fname in ['v2ray', 'v2ctl']:
                        os.chmod(fdst, 755)
                    else:
                        os.chmod(fdst, 644)

    def _get_remote_version(self):
        resp = request.urlopen(LATEST_V2RAY_TAG_URL)
        if resp.status == 200:
            tag_info = json.load(resp)
            m = re.search(r'(\d)\.(\d+)\.(\d+)', tag_info.get('name', ''))
            if m:
                remote_version = [int(v) for v in m.groups()]
                self.logger.debug('remote version is {}'.format(remote_version))
                return remote_version

        raise GFWException('faild to get remote version')

    def update_binary(self):
        dstpath = os.path.dirname(self.prog.command)
        self.logger.debug('update v2ray binary in {}'.format(dstpath))

        remote_version = self._get_remote_version()
        self.logger.info('Local version: {}, remote version: {}'.format(self.version, remote_version))
        if (self.version < remote_version):
            self.logger.info('do update')
            self._install_binary(remote_version, dstpath)
            self.logger.info('update finished')
        else:
            self.logger.info('do not need to update')

    def install_binary(self):
        try:
            local_bin_path = Utils.find_file('./bin')
        except Exception:
            my_path = os.path.dirname(os.path.abspath(__file__))
            local_bin_path = '{}/{}'.format(my_path, './bin')
            os.mkdir(local_bin_path)

        self.logger.info('install v2ray binary at {}'.format(local_bin_path))
        remote_version = self._get_remote_version()
        self._install_binary(remote_version, local_bin_path)
        self.logger.info('done')


class Rule(object):
    def __init__(self, name, filename, url, domains, socks_local_port):
        self.name = name
        self.filename = filename
        self.url = url
        self.domains = domains
        self.socks_local_port = socks_local_port

    def __repr__(self):
        return {
            'name': self.name,
            'url': self.url,
            'domains': "Total {} domains".format(len(self.domains)),
            'socks_local_port': self.socks_local_port
        }.__repr__()


class Dnsmasq(object):
    def __init__(self, run_dir, conf, international_dns_local_port, port, domestic_dns, rules):
        self.logger = Logger(self.__class__.__name__).logger

        ext_config = conf['ext_config']

        # pid_file 地址必须是绝对路径
        self.config_file = '{}/dnsmasq.conf'.format(run_dir)
        self.pid_file = os.path.abspath('{}/dnsmasq.pid'.format(run_dir))
        self.log_file = '{}/dnsmasq.log'.format(run_dir)

        self.port = port
        self.domestic_dns = domestic_dns

        self._get_config(international_dns_local_port, ext_config, rules)
        self.prog = Prog('dnsmasq',
                         args=['-C', self.config_file, '--log-facility={}'.format(self.log_file),
                               '--pid-file={}'.format(self.pid_file)],
                         pid_file=self.pid_file)

    def __repr__(self):
        return 'config: {} ...'.format(self.config[0:100])

    def _get_config(self, dns_local_port, ext_config, rules):
        config_rules = []
        for rule in rules:
            for domain in rule.domains:
                config_rules.append("server=/.{domain}/127.0.0.1#{dns_local_port}\nipset=/.{domain}/{set_name}"
                                    .format(dns_local_port=dns_local_port, set_name=rule.name, domain=domain))

        self.config = "port={}\nserver={}\n{}\n\n{}".format(
            self.port,
            self.domestic_dns,
            ext_config, ""
            # "\n".join(config_rules)
        )

    def start(self):
        self.logger.debug('start dnsmasq')
        with open(self.config_file, 'w') as fh:
            fh.write(self.config)

        self.prog.start(ignore_pid_file=True)

    def stop(self):
        self.logger.debug('stop dnsmasq')
        self.prog.stop()

    def keep_alive(self):
        if not Utils.is_port_open(self.port):
            self.logger.info('dead, do restart')
            self.stop()
            self.start()
        else:
            self.logger.info('alive')

    def status(self):
        if Utils.is_pid_alive_from_file(self.pid_file):
            self.logger.info('dnsmasq is running')
        else:
            self.logger.info('dnsmasq is dead')


class GFW(object):
    def __init__(self, config=CONFIG):
        self.logger = Logger(self.__class__.__name__).logger
        self.logger.debug('init')
        self.config = None
        self.config_err = []

        self.dnsmasq = None
        self.v2ray = None
        self.iptable = None
        self.rules = []

        self.init(config)

    def _ini_to_python(self, config):
        ret = defaultdict(dict)
        for section_name in config.sections():
            for option_name in config.options(section_name):
                ret[section_name][option_name] = config.get(section_name, option_name)
        self.logger.debug('Load ini file')
        return ret

    def _update_list_file_from_remote(self, url, filename):
        resp = request.urlopen(url)
        if resp.status == 200:
            data = base64.b64decode(resp.read())
            with open(filename, 'wb') as fh:
                return fh.write(data)
        return 0

    def init(self, config_str):
        config = configparser.ConfigParser()
        try:
            config.read(Utils.find_file(config_str))
        except Exception:
            config.read_string(config_str)

        conf = self._ini_to_python(config)

        main_section = conf['main']
        main_section['ip_blacklists_src'] = Utils.str_to_list(main_section['ip_blacklists_src'])
        main_section['ip_blacklists_dst'] = Utils.str_to_list(main_section['ip_blacklists_dst'])
        run_dir = Utils.find_file(main_section['run_dir'])
        international_dns = conf['main']['international_dns']
        international_dns_local_port = conf['main']['international_dns_local_port']
        dnsmasq_port = conf['main']['dnsmasq_port']
        domestic_dns = conf['main']['domestic_dns']

        dnsmasq_conf = conf['dnsmasq']
        v2ray_conf = conf['v2ray']

        if not os.path.exists(run_dir):
            os.mkdir(run_dir)

        self.load_domain_rules(conf)
        self.dnsmasq = Dnsmasq(run_dir=run_dir,
                               conf=dnsmasq_conf,
                               international_dns_local_port=international_dns_local_port,
                               port=dnsmasq_port,
                               domestic_dns=domestic_dns,
                               rules=self.rules)

        self.v2ray = V2ray(run_dir=run_dir,
                           conf=v2ray_conf,
                           rules=self.rules,
                           international_dns=international_dns,
                           international_dns_local_port=international_dns_local_port)

        self.iptable = Iptable(run_dir=run_dir,
                               rules=self.rules,
                               dnsmasq_port=dnsmasq_port,
                               domestic_dns=domestic_dns,
                               ip_blacklists_dst=main_section['ip_blacklists_dst'],
                               ip_blacklists_src=main_section['ip_blacklists_src'])

        self.config = {'main': main_section, 'dnsmasq': self.dnsmasq, 'v2ray': self.v2ray}
        self.logger.debug(self.config)

    def load_domain_rules(self, conf):
        lists_dir = Utils.find_file(conf['main']['lists_dir'])

        def sort_func(name):
            if name == 'list_gfwlist':
                return 1
            return -1

        for section_name in sorted(conf.keys(), key=sort_func):
            m = re.match(r'^list_(.*)', section_name)
            if not m:
                continue

            list_name = m.group(1)
            list_filename = "{}/{}".format(lists_dir, list_name)
            list_url = conf[section_name].get('url', '')

            rule = Rule(list_name, list_filename, list_url, [], conf[section_name].get('socks_local_port'))
            if os.path.exists(list_filename):
                rule.domains = Utils.read_file_to_list(list_filename)
            else:
                raise GFWException("List file {} for {} not found".format(list_filename, list_name))

            self.rules.append(rule)

    def check(self):
        self.logger.info('ok')

    def keep_alive(self):
        self.dnsmasq.keep_alive()
        self.v2ray.keep_alive()
        self.iptable.keep_alive()

    def _process_gfw_list(self, content):
        ret = set()
        data = base64.b64decode(content).decode('utf8')
        regexs = [
            [r'^!.*$|^@@.*$|^\[AutoProxy.*$', '', re.IGNORECASE | re.M],
            [r'^\|\|?|\|$', '', re.M],  # ||
            [r'^https?:/?/?', '', re.IGNORECASE | re.M],  # https://
            [r'(/|%).*$', '', re.M],  # url path
            [r'[^.\n]*\*[^.\n]*\.?', '', re.M],  # abc*abc.
            [r'^\*?\.|^.*\.\*?$', '', re.M],  # *. or .*
            [r'^\d+\.\d+\.\d+\.\d+(:\d+)?$', '', re.M],  # ip:port
            [r'^[^.]*[.]*$', '', re.M],  # lines not include .
        ]
        for regex in regexs:
            (pattern, replace, flags) = regex
            data = re.sub(pattern, replace, data, flags=flags)
        for domain in data.split("\n"):
            if domain:
                ret.add(domain)
        return ret

    def _update_gfw_list(self, url, filename):
        self.logger.debug('start update gfwlist')
        resp = request.urlopen(url)
        if resp.status == 200:
            domains = self._process_gfw_list(resp.read())

        self.logger.debug('fetched {} domains from remote'.format(len(domains)))
        ext_filename = filename + '.ext'
        if os.path.exists(ext_filename):
            with open(ext_filename) as fh:
                lines = fh.read().splitlines()
                self.logger.debug('process ext file, include {} lines'.format(len(lines)))
                for domain in lines:
                    domains.add(domain)

        with open(filename, 'w') as fh:
            for domain in domains:
                fh.write("{}\n".format(domain))

        self.logger.info('total domain {}'.format(len(domains)))

    def update_list(self):
        for rule in self.rules:
            if rule.url:
                self.logger.debug('retrive {} from {}'.format(rule.name, rule.url))
                count = self._update_list_file_from_remote(rule.url, rule.filename)
                self.logger.debug('fetched {} lines'.format(count))
            elif rule.name == 'gfwlist':
                url = self.config['main']['gfwlist']
                self._update_gfw_list(url, rule.filename)

    def update_v2ray(self):
        self.v2ray.update_binary()

    def install_v2ray(self):
        self.v2ray.install_binary()

    def status(self):
        self.v2ray.status()
        self.dnsmasq.status()
        self.iptable.status()

    def confirm_network_available(self):
        resp = request.urlopen('https://www.baidu.com/')
        if resp.status != 200:
            raise GFWException('Network not available')

    def start(self):
        self.confirm_network_available()
        self.v2ray.start()
        self.dnsmasq.start()
        self.iptable.start()
        self.status()

    def stop(self):
        self.v2ray.stop()
        self.dnsmasq.stop()
        self.iptable.stop()


def main():
    commands = {
        'start': 'Start proxy',
        'stop': 'Stop proxy and clean all rules',
        'restart': 'Restart proxy',
        'status': 'Show running status',
        'update_list': 'Update lists to the latested version',
        'keep_alive': 'Keep v2ray and dnsmasq are alive',
        'update_v2ray': 'Update v2ray binary',
        'install_v2ray': 'Install v2ray binary',
        'check': 'Check if the envirments are ok'
    }

    parser = argparse.ArgumentParser(
        formatter_class=argparse.RawTextHelpFormatter,
        description='Simple V2ray wrapper to get across the GFW, version {}'.format(__VERSION__),
        usage="%(prog)s [--debug] {}".format('|'.join(commands.keys()))
    )

    parser.add_argument('command',
                        help="{}".format("\n".join(
                            ["{:15s}: {}".format(k, v) for k, v in commands.items()]
                        )),
                        nargs='?',
                        choices=commands.keys())

    parser.add_argument('--debug', '-d', help='Show debug messages', action="store_true", default=False)
    parser.add_argument('--full-log', '-l', help='Add logging to v2ray, dnsmasq for debug',
                        action="store_true", default=False)

    opts = parser.parse_args()
    if opts.debug:
        global default_logging_level
        default_logging_level = logging.DEBUG
        Utils.logger.setLevel(default_logging_level)

    uname = platform.uname()
    Utils.logger.debug('version {} run on {}/{}/{}'.format(__VERSION__, uname.system, uname.release, uname.machine))
    try:
        gfw = GFW()
        if opts.command == 'check':
            gfw.check()
        elif opts.command == 'update_list':
            gfw.update_list()
        elif opts.command == 'start':
            gfw.start()
        elif opts.command == 'stop':
            gfw.stop()
        elif opts.command == 'restart':
            gfw.stop()
            time.sleep(1)
            gfw.start()
        elif opts.command == 'status':
            gfw.status()
        elif opts.command == 'keep_alive':
            gfw.keep_alive()
        elif opts.command == 'update_v2ray':
            gfw.update_v2ray()
        elif opts.command == 'install_v2ray':
            gfw.install_v2ray()

    except Exception as e:
        Utils.logger.debug(traceback.format_exc())
        Utils.logger.info('Exception: {}'.format(e))


if __name__ == '__main__':
    main()
