#!/usr/bin/env python3
# -*- mode: python; -*-
import json
import argparse
import logging
import sys
import re
import configparser
from collections import defaultdict
import os.path
from urllib import request
import base64
import copy
import time
import subprocess
import traceback
import platform
import socket
import tempfile
import zipfile

__VERSION__ = '0.1'

default_logging_level = logging.INFO
LATEST_V2RAY_TAG_URL = 'https://api.github.com/repos/v2ray/v2ray-core/releases/latest'
V2RAY_DOWNLOAD_LINK = "https://github.com/v2ray/v2ray-core/releases/download/v{version}/v2ray-{arch}.zip"
CONFIG = 'config.ini'


class Logger():
    def __init__(self, name):
        logformat = '%(asctime)s %(name)s: %(levelname)s [%(funcName)s/%(lineno)d] %(message)s'
        self.logger = logging.getLogger(name)
        self.logger.setLevel(default_logging_level)
        myhandler = logging.StreamHandler(stream=sys.stdout)
        myhandler.setFormatter(logging.Formatter(logformat))
        self.logger.addHandler(myhandler)


class Utils(object):
    logger = Logger('Utils').logger

    @staticmethod
    def get_command_version(args, regex):
        p = subprocess.run(args, capture_output=True)
        if p.returncode:
            raise Exception('Command {} run faild: {}'.format(args, p.stderr))
        if p.stdout:
            match_str = p.stdout.decode('utf-8')
            m = re.search(regex, match_str)
            if m:
                return [int(v) for v in m.groups()]
        raise Exception('No version found for command {}'.format(args))

    @staticmethod
    def str_to_list(ips):
        if ips:
            res = re.split(r' *[,;] *', ips)
        else:
            res = []
        return res

    @staticmethod
    def split_ip_port(ip, default_port):
        ip = ip.split(':')
        if len(ip) > 1:
            ip = ip[0]
            port = ip[1]
        else:
            ip = ip[0]
            port = default_port
        return ip, port

    @staticmethod
    def read_file_to_list(filename):
        lines = []
        with open(filename, 'r') as infile:
            lines = infile.read().splitlines()
        return lines

    @staticmethod
    def run_command(command, args, stdout=None, stderr=None, background=False, check_func=None):
        Utils.logger.debug('Run command {} args {}'.format(command, args))
        p = subprocess.Popen(args, stdout=stdout, stderr=stderr, stdin=(open('/dev/null', 'r')))
        if not background:
            p.wait()
            return p.returncode
        else:
            if check_func:
                return check_func(p)
            return p.pid

    @staticmethod
    def get_pid(pid_file):
        lines = None
        if os.path.exists(pid_file):
            with open(pid_file, 'r') as fh:
                lines = fh.read().splitlines()

        if lines:
            return int(lines[0].rstrip())
        else:
            return None

    @staticmethod
    def is_port_open(ports):
        if type(ports) is not list:
            ports = [ports]

        for port in ports:
            with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as sock:  # TCP
                try:
                    result = sock.connect_ex(('127.0.0.1', int(port)))
                    if result != 0:
                        raise Exception("Port {} is closed".format(port))
                    else:
                        Utils.logger.debug("Port {} is open".format(port))
                except Exception as e:
                    Utils.logger.debug(e)
                    return False
        return True

    @staticmethod
    def is_pid_alive(pid):
        try:
            os.kill(pid, 0)
        except Exception:
            return False
        return True

    @staticmethod
    def is_pid_alive_from_file(pid_file):
        pid = Utils.get_pid(pid_file)
        if pid:
            return Utils.is_pid_alive(pid)
        else:
            return False

    @staticmethod
    def stop_from_pid_file(pid_file):
        pid = Utils.get_pid(pid_file)
        if Utils.is_pid_alive(pid):
            os.kill(pid, 9)
        return True

    @staticmethod
    def find_file(fname):
        my_path = os.path.dirname(os.path.abspath(__file__))
        fname_with_path = '{}/{}'.format(my_path, fname)
        if os.path.exists(fname):
            return fname
        elif os.path.exists(fname_with_path):
            return fname_with_path
        raise Exception('File {} not found.'.format(fname))

    @staticmethod
    def which(program, path_list=None):
        if not path_list:
            path_list = []

        def is_exe(fpath):
            return os.path.isfile(fpath) and os.access(fpath, os.X_OK)

        fpath, fname = os.path.split(program)
        if fpath:
            if is_exe(program):
                return program
        else:
            for path in [*path_list, *os.environ["PATH"].split(os.pathsep)]:
                exe_file = os.path.join(path, program)
                if is_exe(exe_file):
                    return exe_file

        return None

    @staticmethod
    def check_log_output(file, regex=None, linecount=None, timeout=5):
        time_used = 0
        outputs = ''
        with open(file, 'r') as fh:
            while True:
                outputs += fh.read()
                check_res = False
                if (outputs and regex):
                    check_res = re.search(regex, outputs)
                elif (outputs and linecount):
                    if len(outputs.rstrip().split("\n")) == linecount:
                        check_res = True
                if check_res:
                    Utils.logger.debug('program output: {}'.format(outputs))
                    return True
                if (time_used < timeout):
                    Utils.logger.debug('check output {}'.format(time_used))
                    time.sleep(1)
                    time_used += 1
                else:
                    Utils.logger.debug('program output: {}'.format(outputs))
                    return False

        return None


class Iptable(object):
    def __init__(self):
        self.logger = Logger(self.__class__.__name__).logger

    def init(self, conf, dnsmasq):
        err = []

        command = 'iptables'
        self.command = Utils.which(command)
        if not self.command:
            err.append('Command {} not found.'.format(command))

        self.chain_name = 'SVGFW'
        self.start_commands = [
            [self.command, '-t', 'nat', '-N', self.chain_name],
            [self.command, '-t', 'nat', '-N', self.chain_name],
        ]

        for ip in conf['main']['ip_blacklists_src']:
            self.start_commands.append([
                self.command, '-t', 'nat', '-A', self.chain_name, '-s', ip, '-j', 'ACCEPT'
            ])

        for ip in conf['main']['ip_blacklists_dst']:
            self.start_commands.append([
                self.command, '-t', 'nat', '-A', self.chain_name, '-d', ip, '-j', 'ACCEPT'
            ])

        self.start_commands.extend([
            # accept the domestic dns request
            [self.command, '-t', 'nat', '-A', self.chain_name, '-d', dnsmasq.domestic_server,
             '-p', 'udp', '--dport', '53', '-j', 'ACCEPT'],

            # hijack all other dns requests
            [self.command, '-t', 'nat', '-A', self.chain_name, '-p', 'udp', '--dport', '53',
             '-j', 'REDIRECT', '--to-ports', dnsmasq.port],

            [self.command, '-t', 'nat', '-A', 'PREROUTING', '-j', self.chain_name],  # lan
            [self.command, '-t', 'nat', '-A', 'OUTPUT', '-j', self.chain_name],  # router
        ])

        self.stop_commands = [
            [self.command, '-t', 'nat', '-D', 'PREROUTING', '-j', self.chain_name],
            [self.command, '-t', 'nat', '-D', 'OUTPUT', '-j', self.chain_name],
            [self.command, '-t', 'nat', '-F', self.chain_name],  # flush chain
            [self.command, '-t', 'nat', '-X', self.chain_name],  # delete chain
        ]

        for rule in dnsmasq.rules:
            self.start_commands.append([
                'ipset', 'create', rule.name, 'hash:net'
            ])
            self.stop_commands.append(
                ['ipset', 'destroy', rule.name]
            )

            self.start_commands.append([
                self.command, '-t', 'nat', '-A', self.chain_name,
                '-p', 'tcp',
                '-m', 'set', '--match-set', rule.name, 'dst',
                '-j', 'REDIRECT', '--to-ports', rule.socks_local_port
            ])
            self.start_commands.append([
                self.command, '-t', 'nat', '-A', self.chain_name,
                '-p', 'udp',
                '-m', 'set', '--match-set', rule.name, 'dst',
                '-j', 'REDIRECT', '--to-ports', rule.socks_local_port
            ])
        return err

    def start(self):
        self.logger.debug('start iptables')
        for args in self.start_commands:
            Utils.run_command(self.command, args)

    def stop(self):
        self.logger.debug('stop iptables')
        for args in self.stop_commands:
            Utils.run_command(self.command, args)

    def status(self):
        self.logger.info('iptable is running')


class V2ray(object):
    def __init__(self):
        self.logger = Logger(self.__class__.__name__).logger

    def __repr__(self):
        return {
            'inbounds': self.config['inbounds'],
            'routing': self.config['routing']
        }.__repr__()

    def init(self, conf, rules):
        err = []
        dns = conf['main']['dns']
        dns_local_port = conf['main']['dns_local_port']
        command = conf['v2ray']['v2ray']

        try:
            local_bin_path = [Utils.find_file('./bin')]
        except Exception:
            local_bin_path = []

        self.command = Utils.which(
            command,
            [*local_bin_path, '/opt/v2ray', '/usr/local/bin', '/usr/bin/v2ray'])
        self.version = None
        if not self.command:
            err.append('Command {} not found.'.format(command))
        else:
            self.version = Utils.get_command_version([self.command, '--version'],
                                                     r'V2Ray (\d)\.(\d+)\.(\d+)')

        self.logger.debug('V2ray version {}'.format(self.version))

        run_dir = Utils.find_file(conf['main']['run_dir'])

        self.config_file = "{}/v2ray_config.json".format(run_dir)
        self.pid_file = "{}/v2ray.pid".format(run_dir)
        self.log_file = "{}/v2ray.log".format(run_dir)

        outbounds = conf['v2ray']['outbounds']
        inbounds = conf['v2ray']['inbounds']
        self.rules = rules

        outbounds = re.sub(r'//.*', '', outbounds, re.M)  # remove comments
        self.outbounds = json.loads(outbounds)
        err.extend(self._check_v2ray_config())

        inbounds = re.sub(r'//.*', '', inbounds, re.M)  # remove comments
        if inbounds:
            inbounds = json.loads(inbounds)

        self.config = {
            'log': {"loglevel": "none"},
            'inbounds': self._get_v2ray_inbounds(dns_local_port, dns, inbounds or []),
            'outbounds': self.outbounds,
            'routing': self._get_v2ray_routing(inbounds)
        }

        return err

    def _check_v2ray_config(self):
        tags = {}
        err = []
        for outbound in self.outbounds:
            if outbound.get('tag'):
                tags[outbound['tag']] = 1
            else:
                err.append('Outbound must set a tag.')

        for rule in self.rules:
            if not tags.get(rule.name):
                err.append('Outbound tag for "{}" not found'.format(rule.name))
        return err

    def _check_config(self):
        check_args = [self.command, '--config', self.config_file, '--test']

        self.logger.debug('check v2ray config file')
        code = Utils.run_command('v2ray', check_args, stdout=open('/dev/null', 'w'))
        if code:
            raise Exception("v2ray config file check error")

    def _run(self):
        run_args = [self.command, '--config', self.config_file]
        self.logger.debug('run v2ray')

        def check_func(p):
            if Utils.check_log_output(self.log_file,
                                      linecount=2,
                                      timeout=5):
                return p.pid
            return None

        pid = Utils.run_command('v2ray',
                                run_args,
                                background=True,
                                stdout=open(self.log_file, 'w'),
                                check_func=check_func)

        if not Utils.is_pid_alive(pid):
            raise Exception('start v2ray faild')

        self.logger.debug('done, pid {}'.format(pid))
        with open(self.pid_file, 'w') as fh:
            fh.write(str(pid))

    def start(self):
        self.logger.debug('start v2ray')
        if Utils.is_pid_alive_from_file(self.pid_file):
            raise Exception("Previouse process is still running")

        with open(self.config_file, 'w') as fh:
            fh.write(json.dumps(self.config, indent=4))

        self._check_config()
        self._run()

    def stop(self):
        self.logger.debug('stop v2ray')

        if Utils.stop_from_pid_file(self.pid_file):
            self.logger.debug('done')
        else:
            self.logger.debug('stop faild')

    def status(self):
        if Utils.is_pid_alive_from_file(self.pid_file):
            self.logger.info('v2ray is running')
        else:
            self.logger.info('v2ray is dead')

    def _get_v2ray_inbounds(self, dns_local_port, dns, ext_inbounds):
        dns, port = Utils.split_ip_port(dns, 53)
        inbounds = []
        dns_inbound = {
            "tag": "dns",
            "protocol": "dokodemo-door",
            "port": int(dns_local_port),
            "settings": {
                "address": dns,
                "port": int(port),
                "network": "udp,tcp",
                "followredirect": False
            }
        }
        inbounds.append(dns_inbound)

        socks_inbound_template = {
            "protocol": "dokodemo-door",
            "listen": "0.0.0.0",
            "settings": {
                "followRedirect": True,
                "network": "tcp,udp",
                "timeout": 10
            }
        }

        for rule in self.rules:
            inbound = copy.deepcopy(socks_inbound_template)
            inbound['tag'] = '{}_1'.format(rule.name)  # v2ray didn't support gfwlist as tag name
            inbound['port'] = int(rule.socks_local_port)
            inbounds.append(inbound)

        for inb in ext_inbounds:
            inbounds.append(inb)

        return inbounds

    def keep_alive(self):
        ports = []
        for out in self.config['inbounds']:
            ports.append(out['port'])

        if not Utils.is_port_open(ports):
            self.stop()
            self.start()

    def _get_v2ray_routing(self, ext_inbounds):
        routings = []

        routing_template = {
            "type": "field",
            "network": "tcp,udp"
        }

        for rule in self.rules:
            routing = copy.deepcopy(routing_template)
            routing['inboundTag'] = ['{}_1'.format(rule.name)]
            routing['outboundTag'] = rule.name
            routings.append(routing)

        routings[-1]['inboundTag'].append('dns')  # dns proxy use gfwlist rule
        for inbound in ext_inbounds:
            routings[-1]['inboundTag'].append(inbound['tag'])

        return {'rules': routings}

    def _install_binary(self, version, dstpath):
        files_to_update = ['v2ctl', 'v2ray', 'v2ctl.sig', 'v2ray.sig', 'geoip.dat', 'geosite.dat']

        for f in files_to_update:
            fpath = '{}/{}'.format(dstpath, f)
            if not ((not os.path.exists(fpath) and os.access(dstpath, os.W_OK))
                    or os.access(fpath, os.W_OK)):
                raise Exception("file {} can't be write".format(fpath))

        uname = platform.uname()
        arch = ''
        if uname.system == 'Darwin':
            arch = 'macos'
        elif uname.system == 'Linux':
            if uname.machine == 'aarch64':
                arch = 'linux-arm64'
        if not arch:
            self.logger.info('this system not support update: {}'.format(uname))
            return

        link = V2RAY_DOWNLOAD_LINK.format(version='.'.join([str(v) for v in version]), arch=arch)
        resp = request.urlopen(link)
        if resp.status != 200:
            raise Exception('download zip file faild.')

        tmpfile = tempfile.NamedTemporaryFile(delete=True)
        self.logger.debug('tempfile is {}'.format(tmpfile.name))
        tmpfile.write(resp.read())
        with zipfile.ZipFile(tmpfile) as zip:
            with tempfile.TemporaryDirectory() as tmppath:
                self.logger.debug('extract files {} to {}'.format(files_to_update, tmppath))
                zip.extractall(members=files_to_update, path=tmppath)
                for fname in files_to_update:
                    fsrc = '{}/{}'.format(tmppath, fname)
                    fdst = '{}/{}'.format(dstpath, fname)
                    self.logger.debug('cp {}'.format(fdst))
                    os.system('cp -p {} {}'.format(fsrc, fdst))
                    if fname in ['v2ray', 'v2ctl']:
                        os.chmod(fdst, 755)
                    else:
                        os.chmod(fdst, 644)

    def _get_remote_version(self):
        resp = request.urlopen(LATEST_V2RAY_TAG_URL)
        if resp.status == 200:
            tag_info = json.load(resp)
            m = re.search(r'(\d)\.(\d+)\.(\d+)', tag_info.get('name', ''))
            if m:
                remote_version = [int(v) for v in m.groups()]
                self.logger.debug('remote version is {}'.format(remote_version))
                return remote_version

        raise Exception('faild to get remote version')

    def update_binary(self):
        dstpath = os.path.dirname(self.command)
        self.logger.debug('update v2ray binary in {}'.format(dstpath))

        remote_version = self._get_remote_version()
        self.logger.info('Local version: {}, remote version: {}'.format(self.version, remote_version))
        if (self.version < remote_version):
            self.logger.info('do update')
            self._install_binary(remote_version, dstpath)
            self.logger.info('update finished')
        else:
            self.logger.info('do not need to update')

    def install_binary(self):
        try:
            local_bin_path = Utils.find_file('./bin')
        except Exception:
            my_path = os.path.dirname(os.path.abspath(__file__))
            local_bin_path = '{}/{}'.format(my_path, './bin')
            os.mkdir(local_bin_path)

        self.logger.info('install v2ray binary at {}'.format(local_bin_path))
        remote_version = self._get_remote_version()
        self._install_binary(remote_version, local_bin_path)
        self.logger.info('done')


class Dnsmasq(object):
    class Rule(object):
        def __init__(self, name, filename, url, domains, socks_local_port):
            self.name = name
            self.filename = filename
            self.url = url
            self.domains = domains
            self.socks_local_port = socks_local_port

        def __repr__(self):
            return {
                'name': self.name,
                'url': self.url,
                'domains': "Total {} domains".format(len(self.domains)),
                'socks_local_port': self.socks_local_port
            }.__repr__()

    def __init__(self):
        self.logger = Logger(self.__class__.__name__).logger
        self.rules = []

    def __repr__(self):
        return {
            'rules': self.rules,
        }.__repr__()

    def init(self, conf):
        err = self._init_rules(conf)

        run_dir = Utils.find_file(conf['main']['run_dir'])

        self.config_file = '{}/dnsmasq.conf'.format(run_dir)
        self.pid_file = '{}/dnsmasq.pid'.format(run_dir)
        self.log_file = '{}/dnsmasq.log'.format(run_dir)

        command = conf['dnsmasq']['dnsmasq']
        self.port = conf['dnsmasq']['port']
        self.domestic_server = conf['dnsmasq']['domestic_server']

        self.command = Utils.which(command)
        if not self.command:
            err.append('Command {} not found.'.format(command))

        self._get_config(conf)
        return err

    def _get_config(self, conf):
        dns_local_port = conf['main']['dns_local_port']
        config = conf['dnsmasq']['config']

        config_rules = []
        for rule in self.rules:
            for domain in rule.domains:
                config_rules.append("server=/.{domain}/127.0.0.1#{dns_local_port}\nipset=/.{domain}/{set_name}"
                                    .format(dns_local_port=dns_local_port, set_name=rule.name, domain=domain))

        self.config = "port={}\nserver={}\n{}\n\n{}".format(
            self.port, self.domestic_server,
            config, "\n".join(config_rules)
        )

    def _init_rules(self, conf):
        err = []
        lists_dir = Utils.find_file(conf['main']['lists_dir'])

        def sort_func(name):
            if name == 'list_gfwlist':
                return 1
            return -1

        for section_name in sorted(conf.keys(), key=sort_func):
            m = re.match(r'^list_(.*)', section_name)
            if not m:
                continue

            list_name = m.group(1)
            list_filename = "{}/{}".format(lists_dir, list_name)
            list_url = conf[section_name].get('url', '')

            rule = Dnsmasq.Rule(list_name, list_filename, list_url, [], conf[section_name].get('socks_local_port'))
            if os.path.exists(list_filename):
                rule.domains = Utils.read_file_to_list(list_filename)
            else:
                err = "List file {} for {} not found".format(list_filename, list_name)
                self.logger.debug(err)
                err.append(err)

            self.rules.append(rule)
        return err

    def start(self):
        self.logger.debug('start dnsmasq')
        if Utils.is_pid_alive_from_file(self.pid_file):
            raise Exception("Previouse process is still running")

        with open(self.config_file, 'w') as fh:
            fh.write(self.config)

        run_args = [self.command, '-C', self.config_file, '--log-facility=-', '--pid-file={}'.format(self.pid_file)]

        def check_func(p):
            if Utils.check_log_output(self.log_file,
                                      regex=r'dnsmasq\[\d+\]: started',
                                      timeout=5):
                return p.pid
            return None

        self.logger.debug('run dnsmasq')
        pid = Utils.run_command(self.command,
                                run_args,
                                background=True,
                                stderr=open(self.log_file, 'w'),
                                check_func=check_func)

        pid = Utils.get_pid(self.pid_file)
        if not Utils.is_pid_alive(pid):
            raise Exception("start dnsmasq faild.")

        self.logger.debug('done, pid {}'.format(pid))
        with open(self.pid_file, 'w') as fh:
            fh.write(str(pid))

    def stop(self):
        self.logger.debug('stop dnsmasq')

        if Utils.stop_from_pid_file(self.pid_file):
            self.logger.debug('done')
        else:
            self.logger.debug('stop faild')

    def keep_alive(self):
        if not Utils.is_port_open(self.port):
            self.stop()
            self.start()

    def status(self):
        if Utils.is_pid_alive_from_file(self.pid_file):
            self.logger.info('dnsmasq is running')
        else:
            self.logger.info('dnsmasq is dead')


class GFW(object):
    def __init__(self):
        self.logger = Logger(self.__class__.__name__).logger
        self.logger.debug('init')
        self.config = None
        self.config_err = []

        self.dnsmasq = Dnsmasq()
        self.v2ray = V2ray()
        self.iptable = Iptable()

        self.init()

    def _ini_to_python(self, config):
        ret = defaultdict(dict)
        for section_name in config.sections():
            for option_name in config.options(section_name):
                ret[section_name][option_name] = config.get(section_name, option_name)
        self.logger.debug('Load ini file')
        return ret

    def _update_list_file_from_remote(self, url, filename):
        resp = request.urlopen(url)
        if resp.status == 200:
            data = base64.b64decode(resp.read())
            with open(filename, 'wb') as fh:
                return fh.write(data)
        return 0

    def init(self):
        config = configparser.ConfigParser()
        config.read(Utils.find_file(CONFIG))
        conf = self._ini_to_python(config)

        main_section = conf['main']
        main_section['ip_blacklists_src'] = Utils.str_to_list(main_section['ip_blacklists_src'])
        main_section['ip_blacklists_dst'] = Utils.str_to_list(main_section['ip_blacklists_dst'])
        run_dir = Utils.find_file(main_section['run_dir'])

        if not os.path.exists(run_dir):
            os.mkdir(run_dir)

        err1 = self.dnsmasq.init(conf)
        if err1:
            self.config_err.extend(err1)

        err2 = self.v2ray.init(conf=conf, rules=self.dnsmasq.rules)
        if err2:
            self.config_err.extend(err2)

        err3 = self.iptable.init(conf=conf, dnsmasq=self.dnsmasq)
        if err3:
            self.config_err.extend(err3)

        self.config = {'main': main_section, 'dnsmasq': self.dnsmasq, 'v2ray': self.v2ray}
        self.logger.debug(self.config)

    def check(self):
        if self.config_err:
            raise Exception("\n".join(self.config_err))

        self.logger.info('ok')

    def keep_alive(self):
        self.dnsmasq.keep_alive()
        self.v2ray.keep_alive()

    def _process_gfw_list(self, content):
        ret = set()
        data = base64.b64decode(content).decode('utf8')
        regexs = [
            [r'^!.*$|^@@.*$|^\[AutoProxy.*$', '', re.IGNORECASE | re.M],
            [r'^\|\|?|\|$', '', re.M],  # ||
            [r'^https?:/?/?', '', re.IGNORECASE | re.M],  # https://
            [r'(/|%).*$', '', re.M],  # url path
            [r'[^.\n]*\*[^.\n]*\.?', '', re.M],  # abc*abc.
            [r'^\*?\.|^.*\.\*?$', '', re.M],  # *. or .*
            [r'^\d+\.\d+\.\d+\.\d+(:\d+)?$', '', re.M],  # ip:port
            [r'^[^.]*[.]*$', '', re.M],  # lines not include .
        ]
        for regex in regexs:
            (pattern, replace, flags) = regex
            data = re.sub(pattern, replace, data, flags=flags)
        for domain in data.split("\n"):
            if domain:
                ret.add(domain)
        return ret

    def _update_gfw_list(self, url, filename):
        self.logger.debug('start update gfwlist')
        resp = request.urlopen(url)
        if resp.status == 200:
            domains = self._process_gfw_list(resp.read())

        self.logger.debug('fetched {} domains from remote'.format(len(domains)))
        ext_filename = filename + '.ext'
        if os.path.exists(ext_filename):
            with open(ext_filename) as fh:
                lines = fh.read().splitlines()
                self.logger.debug('process ext file, include {} lines'.format(len(lines)))
                for domain in lines:
                    domains.add(domain)

        with open(filename, 'w') as fh:
            for domain in domains:
                fh.write("{}\n".format(domain))

        self.logger.info('total domain {}'.format(len(domains)))

    def update_list(self):
        for rule in self.dnsmasq.rules:
            if rule.url:
                self.logger.debug('retrive {} from {}'.format(rule.name, rule.url))
                count = self._update_list_file_from_remote(rule.url, rule.filename)
                self.logger.debug('fetched {} lines'.format(count))
            elif rule.name == 'gfwlist':
                url = self.config['main']['gfwlist']
                self._update_gfw_list(url, rule.filename)

    def update_v2ray(self):
        self.v2ray.update_binary()

    def install_v2ray(self):
        self.v2ray.install_binary()

    def status(self):
        self.v2ray.status()
        self.dnsmasq.status()
        self.iptable.status()

    def confirm_network_available(self):
        resp = request.urlopen('https://www.baidu.com/')
        if resp.status != 200:
            raise Exception('Network not available')

    def start(self):
        self.confirm_network_available()
        self.v2ray.start()
        self.dnsmasq.start()
        self.iptable.start()
        self.status()

    def stop(self):
        self.v2ray.stop()
        self.dnsmasq.stop()
        self.iptable.stop()


def main():
    commands = {
        'start': 'Start proxy',
        'stop': 'Stop proxy and clean all rules',
        'restart': 'Restart proxy',
        'status': 'Show running status',
        'update_list': 'Update lists to the latested version',
        'keep_alive': 'Keep v2ray and dnsmasq are alive',
        'update_v2ray': 'Update v2ray binary',
        'install_v2ray': 'Install v2ray binary',
        'check': 'Check if the envirments are ok'
    }

    parser = argparse.ArgumentParser(
        formatter_class=argparse.RawTextHelpFormatter,
        description='Simple V2ray wrapper to get across the GFW',
        usage="%(prog)s [--debug] {}".format('|'.join(commands.keys()))
    )

    parser.add_argument('command',
                        help="{}".format("\n".join(
                            ["{:15s}: {}".format(k, v) for k, v in commands.items()]
                        )),
                        nargs='?',
                        choices=commands.keys())

    parser.add_argument('--debug', '-d', help='Show debug messages', action="store_true", default=False)
    parser.add_argument('--full-log', '-l', help='Add logging to v2ray, dnsmasq for debug',
                        action="store_true", default=False)

    opts = parser.parse_args()
    if opts.debug:
        global default_logging_level
        default_logging_level = logging.DEBUG
        Utils.logger.setLevel(default_logging_level)

    uname = platform.uname()
    Utils.logger.debug('version {} run on {}/{}/{}'.format(__VERSION__, uname.system, uname.release, uname.machine))
    try:
        gfw = GFW()
        if opts.command == 'check':
            gfw.check()
        if opts.command == 'update_list':
            gfw.check()
            gfw.update_list()
        elif opts.command == 'start':
            gfw.check()
            gfw.start()
        elif opts.command == 'stop':
            gfw.check()
            gfw.stop()
        elif opts.command == 'restart':
            gfw.stop()
            time.sleep(1)
            gfw.check()
            gfw.start()
        elif opts.command == 'status':
            gfw.check()
            gfw.status()
        elif opts.command == 'keep_alive':
            gfw.check()
            gfw.keep_alive()
        elif opts.command == 'update_v2ray':
            gfw.check()
            gfw.update_v2ray()
        elif opts.command == 'install_v2ray':
            gfw.install_v2ray()

    except Exception as e:
        Utils.logger.debug(traceback.format_exc())
        Utils.logger.info('Exception: {}'.format(e))


if __name__ == '__main__':
    main()
